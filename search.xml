<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>node.js第二天的学习</title>
      <link href="/2020/02/12/node.js02/"/>
      <url>/2020/02/12/node.js02/</url>
      
        <content type="html"><![CDATA[<p>ip地址和域名</p><p>ip地址是每个服务器都特有的表示，客户端同ip地址可以找到指定的服务器，而域名则是网址名，一般都是将域名转换为ip地址才能找到服务器</p><p>端口就是服务器提供给客户端的一些服务类型，比如客户端浏览器要想向服务器发送web请求，那么这个时候服务器就会有对应的web服务端口(80端口)去接收这个请求，再比如浏览器向服务器发送了发送邮件的请求，那么服务器就会有一个专门处理邮件问题的端口去接受这个请求。</p><p>url</p><p>统一资源定位符</p><p>就是服务器端资源所在的位置，一般由网络协议、ip/域名：端口、资源所在位置等组成</p><p>在开发阶段我们自己的电脑如果安装服务器端的运行环境就可以用来创建接收客户端信息的对象，来响应客户端的请求，本地服务器的域名为localhost 本地ip127.0.0.1    可以用localhost来访问到自己的电脑就是开发者自己电脑上的本地服务器</p><p>创建网站服务器</p><p>首先需要引入http模块，使用creatServer()创建服务器对象，然后监听客户端请求事件，事件处理函数中有两个参数，一个是请求对象，一个响应对象，简单的用响应对象做出响应,然后监听我们的端口(3000),这样一来简单web服务器搭建好了,利用本地域名进行访问</p><p>可以用请求对象获取请求类型请求地址请求消息等等</p><p>可以用响应对象对客户端返回一些信息，如响应头中修改状态码和响应报文的一些信息</p><p>一般用on方法绑定一些事件</p><h3 id="http协议"><a href="#http协议" class="headerlink" title="http协议"></a><strong>http协议</strong></h3><p>http协议相当于服务器与客户端之间沟通的桥梁、沟通的规范，超文本传输协议,超文本就相当于html</p><p>客户端向服务器端请求数据，服务器接收这个请求并可以做出响应,请求或响应的数据块成为<strong>报文</strong></p><p><strong>请求报文</strong>客户端向服务器发出的请求</p><p>请求头中的信息和响应头中的信息一般是键值对形式对象存在的</p><p>请求方式，告诉服务器这次请求的目的，GET(请求数据)常见的客户端请求数据就是输入网址 post(发送数据)，一般使用post方式更加安全</p><p>一般输入网址为客户端的get请求，表单提交为post请求</p><p><strong>响应报文</strong></p><p>一般响应报文主要是http状态码的形式返回客户端</p><ul><li>200 请求成功</li><li>404 请求的资源没有被找到</li><li>500 服务器端错误</li><li>400 客户端请求有语法错误</li></ul><p>请求参数分为get请求参数和post请求参数</p><p><strong>get请求参数</strong></p><p>一般在浏览器请求地址的时候,地址后面会有请求参数？uname=caoqiang&amp;age=18    以&amp;分隔的键值对形式</p><p>因为这个参数是在url中,因此需要引入url模块来处理这个参数，变成我们想要的对象形式,用parse()方法解析url地址，返回url的信息是一个对象，加第二个参数为true就能将请求参数转化为对象形式</p><p><strong>post请求参数</strong></p><p>格式与请求参数一样，放在请求报文中，而不是放在地址栏中,因此我们需要引用querystring模块去将这个字符串解析成对象,在发送post请求的时候,需要data事件(在传递请求参数的时候触发)和end事件(传递参数结束时触发)</p><pre class=" language-js"><code class="language-js"><span class="token keyword">const</span> http <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'http'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//引入查询字符串模块</span><span class="token keyword">const</span> querystring <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'querystring'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">const</span> app <span class="token operator">=</span> http<span class="token punctuation">.</span><span class="token function">createServer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>app<span class="token punctuation">.</span><span class="token function">on</span><span class="token punctuation">(</span><span class="token string">'request'</span><span class="token punctuation">,</span> <span class="token punctuation">(</span>req<span class="token punctuation">,</span> res<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">//定义一个字符串来进行拼接，因为传递的参数有很多</span>    <span class="token keyword">let</span> str <span class="token operator">=</span> <span class="token string">''</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//请求监听data时end事件</span>    req<span class="token punctuation">.</span><span class="token function">on</span><span class="token punctuation">(</span><span class="token string">'data'</span><span class="token punctuation">,</span> params <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">//传递时进行拼接</span>        str <span class="token operator">+</span><span class="token operator">=</span> params<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span>    req<span class="token punctuation">.</span><span class="token function">on</span><span class="token punctuation">(</span><span class="token string">'end'</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">//传递结束时进行解析成对象</span>        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>querystring<span class="token punctuation">.</span><span class="token function">parse</span><span class="token punctuation">(</span>str<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span>    res<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token string">'ok'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">)</span>app<span class="token punctuation">.</span><span class="token function">listen</span><span class="token punctuation">(</span><span class="token number">3000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'我的第一个服务器创建成功'</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>]]></content>
      
      
      <categories>
          
          <category> node.js </category>
          
      </categories>
      
      
        <tags>
            
            <tag> node.js </tag>
            
            <tag> http协议 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>初始搭建hexo博客</title>
      <link href="/2020/02/12/da-jian-hexo-bo-ke-01/"/>
      <url>/2020/02/12/da-jian-hexo-bo-ke-01/</url>
      
        <content type="html"><![CDATA[<h3 id="第一步准备工作"><a href="#第一步准备工作" class="headerlink" title="第一步准备工作"></a>第一步准备工作</h3><p>首先下载node.js运行环境,去官网下载长期稳定版,node安装好中自带npm包管理工具,因为hexo博客框架是基于node.js的，另外还需要下载git,确认这两个本电脑都已经安装可以去看本地path环境变量是否存在两者路径,如果有则说明安装成功，没有则需自行配置。</p><h3 id="第二步下载hexo"><a href="#第二步下载hexo" class="headerlink" title="第二步下载hexo"></a>第二步下载hexo</h3><p>1.在需要的文件中打开命令行工具,安装hexo命令行全局工具</p><pre><code>npm install -g hexo-cli</code></pre><p>2.然后用hexo命令创建博客文件夹(文件夹名字可自行定义)</p><pre><code>hexo install blog</code></pre><p>3.执行完以上操作后,可以看到生成了blog文件夹,注意里面的.config.yml文件和themes文件(.confing.yml文件是配置网站的一些基本信息，themes是主题后面会详细说明),利用package.json文件里面依赖属性可以下载hexo所需要的依赖包</p><pre><code>npm install</code></pre><p>4.下载完成后会多出一个node_modules的文件夹，这个文件是下好的依赖包</p><p>这样一个基本博客结构就搭建好了,进入到blog文件夹打开命令行启动hexo</p><pre><code>hexo s</code></pre><p>启动之后就可以在本地localhost:4000查看到博客，这样一个基本的本地博客就搭建好了</p><p>一些常用的命令</p><pre><code>hexo server  简写 hexo s         //本地启动hexo generate 简写 hexo g     //生成静态文件hexo deploy 简写 hexo d         //部署到网站hexo clean                     //清除缓存和已经生成的静态文件hexo new    简写 hexo n        //page新建页面    &quot;文章名&quot;新建文章</code></pre><p>更多命令请到<a href="https://hexo.io/zh-cn/docs/commands#new" target="_blank" rel="noopener">https://hexo.io/zh-cn/docs/commands#new</a>中查看</p><h3 id="第三步部署到远端服务器"><a href="#第三步部署到远端服务器" class="headerlink" title="第三步部署到远端服务器"></a>第三步部署到远端服务器</h3><p>部署到自己的github仓库,新建一个仓库,仓库名只能是自己的github ID.github.io</p><p>然后修改_config.yml文件,找到deploy</p><pre><code>deploy:  type: git  repo: git@github.com:ID/ID.github.io.git  branch: master</code></pre><p>然后命令行</p><pre><code>hexo ghexo d</code></pre><p>这样输入<a href="https://id.github.io就可以远端访问博客了,可以自行更换域名,后续会讲" target="_blank" rel="noopener">https://id.github.io就可以远端访问博客了,可以自行更换域名,后续会讲</a></p><h3 id="更换自己想要的主题"><a href="#更换自己想要的主题" class="headerlink" title="更换自己想要的主题"></a>更换自己想要的主题</h3><p>在github上找自己想要的hexo主题,或者hexo官网选择,默认的主题是landscape，在themes文件夹是主题文件夹</p><p>进入到themes文件夹,输入git命令</p><pre><code>git clone 你想要的主题仓库地址</code></pre><p>进入.config.yml，更换主题</p><pre><code># Extensions## Plugins: https://hexo.io/plugins/## Themes: https://hexo.io/themes/theme: 主题名</code></pre><p>去对应主题查看官方文档配置自己想要的样式</p><pre><code>hexo cleanhexo ghexo s</code></pre><h3 id=""><a href="#" class="headerlink" title=""></a></h3>]]></content>
      
      
      <categories>
          
          <category> hexo博客 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>初步使用git</title>
      <link href="/2020/02/12/git/"/>
      <url>/2020/02/12/git/</url>
      
        <content type="html"><![CDATA[<h3 id="进入到需要上传到远端的文件-使用全局配置"><a href="#进入到需要上传到远端的文件-使用全局配置" class="headerlink" title="进入到需要上传到远端的文件,使用全局配置"></a>进入到需要上传到远端的文件,使用全局配置</h3><p>git config –global user.name “github名字”和git config –global user.email “github邮箱”<br>在github上建立远程仓库</p><p>git init进行本地初始化  建立本地暂存区</p><p>readme.md//这个markdown文件是进行说明的文档</p><p>.git文件存储当前项目的所有版本信息</p><p>本地文件夹叫工作区  git init后的是暂存区 github上创建的仓库是远程仓库</p><p>将工作区的文件提交到暂存区<br>git add 文件名 或者 git add *   表示提交所有文件    git commit -m “提交的描述”</p><h3 id="查看当前工作区的状态"><a href="#查看当前工作区的状态" class="headerlink" title="查看当前工作区的状态"></a>查看当前工作区的状态</h3><p>git status  用于查看当前工作区的文件是否被修改</p><p>如果被修改了可以git add 文件名 重新提交修改过的文件    也可以用git checkout 文件名从暂存区恢复文件到工作区</p><h3 id="git-diff-可以详细查看工作区和暂存区的版本区别-看看哪个文件被修改了-修改了什么内容"><a href="#git-diff-可以详细查看工作区和暂存区的版本区别-看看哪个文件被修改了-修改了什么内容" class="headerlink" title="git diff 可以详细查看工作区和暂存区的版本区别 看看哪个文件被修改了 修改了什么内容"></a>git diff 可以详细查看工作区和暂存区的版本区别 看看哪个文件被修改了 修改了什么内容</h3><h3 id="git-log-查看已经提交到暂存区的历史版本"><a href="#git-log-查看已经提交到暂存区的历史版本" class="headerlink" title="git log 查看已经提交到暂存区的历史版本"></a>git log 查看已经提交到暂存区的历史版本</h3><h3 id="恢复文件到指定的某一个版本"><a href="#恢复文件到指定的某一个版本" class="headerlink" title="恢复文件到指定的某一个版本"></a>恢复文件到指定的某一个版本</h3><p>git reset –hard 版本号 </p><p>检查暂存区所有文件都都没有问题后，就可以将暂存区文件上传到github上，但是要先生成ssh密匙授权本电脑   ssh-keygen -t rsa -C “你github邮箱” 就可以生成本机的ssh密匙然后填写到github的ssh选项中  添加成功后就可以从本机将暂存区的文件传到github远程仓库中</p><h3 id="暂存区-gt-远程仓库"><a href="#暂存区-gt-远程仓库" class="headerlink" title="暂存区 =&gt; 远程仓库"></a>暂存区 =&gt; 远程仓库</h3><p>git remote add origin 远程仓库地址<br>git push -u origin master<br>第一次提交会要求输入github用户和密码  </p><p>第二次提交直接git push即可</p><h3 id="git-clone"><a href="#git-clone" class="headerlink" title="git clone"></a>git clone</h3><p>从远程仓库克隆项目到本地</p><h3 id="git-pull"><a href="#git-pull" class="headerlink" title="git pull"></a>git pull</h3><p>从远程仓库同步本地代码,即更新代码</p>]]></content>
      
      
      <categories>
          
          <category> git项目工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>node.js第一天的学习</title>
      <link href="/2020/02/10/node01/"/>
      <url>/2020/02/10/node01/</url>
      
        <content type="html"><![CDATA[<h3 id="进入Node-js的学习"><a href="#进入Node-js的学习" class="headerlink" title="进入Node.js的学习"></a>进入Node.js的学习</h3><p>node为服务器开发，为后面Ajax后端技术做铺垫</p><p>实现网站的业务逻辑    如登录</p><p>数据的增删改查    如购物车</p><p>node使用javascript语法开发后端应用（有大量开源库可以使用）</p><h3 id="Node是什么"><a href="#Node是什么" class="headerlink" title="Node是什么"></a>Node是什么</h3><p>node是跟浏览器一样是javascript的运行环境，不同浏览器通过不同的js引擎来编译JavaScript转化成计算机认识的语言，因此js引擎不同js的运行环境不同，于是node是基于谷歌的js引擎V8来进行开发，达到了开发统一性</p><h3 id="Node-js运行环境"><a href="#Node-js运行环境" class="headerlink" title="Node.js运行环境"></a>Node.js运行环境</h3><p>下载完成后安装目录不要出现中文，用系统命令工具打开执行node，path系统环境变量：存放node.exe路径的，可以通过cmd命令找出来</p><h3 id="Node-js组成"><a href="#Node-js组成" class="headerlink" title="Node.js组成"></a>Node.js组成</h3><p>ES+node模块化api</p><p>如果要在node里运行js文件，应该在命令行中运行，将命令行的路径改成运行文件对应的路径 node 文件名即可运行</p><p>node.js全局对象global        global有一些js中window的方法在Node中可以省略</p><h3 id="Node-js模块化开发"><a href="#Node-js模块化开发" class="headerlink" title="Node.js模块化开发"></a>Node.js模块化开发</h3><p>js的开发有两大问题<strong>文件依赖</strong>和<strong>命名冲突</strong></p><p>软件模块化开发可以一个功能即为一个模块，多个模块组合成一个应用，每一个模块可以独立存在,如果一个模块中有问题，可以把这个模块拿出来修改问题，其他模块不会被影响</p><p>node中一个js文件代表一个模块，在模块内部定义的变量和函数默认情况下在外部无法得到</p><p>node中模块成员导出，即将一个模块中的函数和变量用expotrs导出,在另一个模块中用require(路径)方法返回对象来使用,路径可以不要后缀名</p><pre class=" language-js"><code class="language-js"><span class="token keyword">const</span> add <span class="token operator">=</span> <span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> a <span class="token operator">+</span> b<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//想要将一个模块中的函数或者变量取出给另一个模块用</span><span class="token comment" spellcheck="true">//使用exports对象,将函数或者变量作为对象的属性存入</span>exports<span class="token punctuation">.</span>add <span class="token operator">=</span> add<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//在想要导出的函数和变量的模块中，使用require()方法来接收，返回值为exports对象</span><span class="token keyword">const</span> a <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'./03.module-a'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>a<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">20</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>第二种方法    可以用module.exports对象导出</p><p>exports对象是module.exports对象的别名，两者是指向同一个对象(同一个内存地址),如果以对象.属性导出，两者一样，如果以对象赋值的形式导出，以module.exports对象为准</p><h3 id="系统模块"><a href="#系统模块" class="headerlink" title="系统模块"></a>系统模块</h3><p>Node开发环境提供的API成为系统模块</p><p>系统模块提供了许多模快开发API如<strong>文件系统模块 fs</strong>，首先在另一个模块中使用其他模块得用require引入</p><p>fs中提供了读取文件方法readFile(‘文件路径’[,编码],callback)三个参数</p><p>回调函数中存放方法的返回结果,回调函数有两个参数,<strong>一般node中提供的API中的回调函数第一个参数都是err</strong>表示一个对象，用来存储错误的信息，没有错误信息则为null,第二个参数为文件读取的结果</p><pre class=" language-js"><code class="language-js"><span class="token keyword">const</span> fs <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'fs'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>fs<span class="token punctuation">.</span><span class="token function">readFile</span><span class="token punctuation">(</span><span class="token string">'./.01.helloworld.js'</span><span class="token punctuation">,</span><span class="token string">'utf-8'</span><span class="token punctuation">,</span> <span class="token punctuation">(</span>err<span class="token punctuation">,</span> doc<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">//err是一个对象,存储错误的信息,如果没有错误的信息则为null</span>    <span class="token comment" spellcheck="true">//doc是文件读取的结果</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>err<span class="token punctuation">)</span><span class="token punctuation">;</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>doc<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">)</span></code></pre><p>文件写入内容writeFlie(‘路径’,’数据’,callback)</p><pre class=" language-js"><code class="language-js"><span class="token keyword">const</span> fs <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'fs'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>fs<span class="token punctuation">.</span><span class="token function">writeFile</span><span class="token punctuation">(</span><span class="token string">'./dome.txt'</span><span class="token punctuation">,</span> <span class="token string">'我是即将写入的内容'</span><span class="token punctuation">,</span> err <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">//如果路径中没有这个文件会自动创建</span>    <span class="token comment" spellcheck="true">//err错误信息对象</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>err <span class="token operator">!==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>err<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'文件内容写入成功'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">)</span></code></pre><p>path模块</p><p>window中路径分隔符可以 / \</p><p>Linux中只能/</p><p>路径拼接方法path.join(‘字符串1’…)返回值为拼接好的路径../../</p><h3 id="相对路径和绝对路径"><a href="#相对路径和绝对路径" class="headerlink" title="相对路径和绝对路径"></a>相对路径和绝对路径</h3><p>一般node中都写绝对路径，如果相对路径是相对于文件本身就用相对路径如require(),但是大多数情况下相对路径都是相对于命令行工具所在的目录</p><p>用__dirname获取当前文件夹的绝对路径    再用path.join()拼接路径</p><pre class=" language-js"><code class="language-js"><span class="token keyword">const</span> fs <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'fs'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">const</span> path <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'path'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//当前文件夹绝对路径</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>__dirname<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//拼接好的绝对路径</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>path<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span>__dirname<span class="token punctuation">,</span> <span class="token string">'01.helloworld.js'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>fs<span class="token punctuation">.</span><span class="token function">readFile</span><span class="token punctuation">(</span>path<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span>__dirname<span class="token punctuation">,</span> <span class="token string">'01.helloworld.js'</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token string">'utf-8'</span><span class="token punctuation">,</span> <span class="token punctuation">(</span>err<span class="token punctuation">,</span> doc<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>err<span class="token punctuation">)</span><span class="token punctuation">;</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>doc<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">)</span></code></pre><h3 id="第三方模块"><a href="#第三方模块" class="headerlink" title="第三方模块"></a>第三方模块</h3><p>类似js插件,别人写好具有特定功能，我们可以直接拿来使用,也叫包</p><blockquote><p>第三方模块有两种形式：</p><ol><li>以js文件的形式存在，提供实现项目具体功能的API接口。本地安装</li><li>以命令行工具形式存在，辅助项目开发，例如   全局安装<ol><li>当文件修改时，自动重新node该文件</li><li>将md文档转换为更加通用的HTML文档</li></ol></li></ol></blockquote><h5 id="获取第三方模块"><a href="#获取第三方模块" class="headerlink" title="获取第三方模块"></a>获取第三方模块</h5><p>npm (node package manager) node的第三方模块管理工具</p><p>可以用这个工具到npm官网中下载想要的第三方模块</p><ul><li>所有第三方模块都被统一放置在了一个叫做<a href="https://www.npmjs.com/" target="_blank" rel="noopener">npm</a>的网站中。</li><li>npm网站提供了一个叫npm的命令行工具用以下载此网站中的第三方模块。</li><li>Node环境默认集成了这个工具，所以可以直接使用，使用方式如下：<ul><li>npm install package  =&gt;  用npm命令安装(下载)第三方模块 (文件模块)</li><li>npm install package -g =&gt; 用npm命令安装(下载)第三方模块 (命令行工具)<ul><li>-g表示全局安装，即模块的使用不局限于当前项目，一般用于安装命令行工具。</li></ul></li></ul></li><li>默认情况下文件模块会被下载至一个叫做node_modules的文件夹中，如果文件夹不存在则自动创建。</li><li>全局安装的命令行工具会被下载到C:\Users\用户名\AppData\Roaming\npm文件夹中。</li><li>使用npm命令卸载包的方式<ul><li>npm uninstall package =&gt; 用npm命令卸载包</li></ul></li></ul><p><strong>nodemond第三方模块</strong>命令行工具要全局安装    可以实时检测文件的保存来执行文件    用nodemon来执行文件可以使用这个第三方模块    ctrl+c终止操作</p><p><strong>nrm</strong>全局    快速切换npm下载地址        默认是国外的nmpjs网站下载    切换到国内淘宝的下载地址    nrm ls下载地址列表 nrm use taobao    提高下载速度</p><h3 id="glup第三方模块"><a href="#glup第三方模块" class="headerlink" title="glup第三方模块"></a>glup第三方模块</h3><p>gulp提供的方法</p><p>gulp.src()获取任务要处理的文件    参数路径</p><p>gulp.dest() 输出文件，将处理好的文件输出 参数输出路径</p><p>gulp.task() 建立gulp任务</p><p>gulp.watch() 监控文件的变化</p><p>一般要在项目使用gulp模块，首先在npm中下载本地gulp库文件，当在项目目录中，创建一个src文件夹存放项目的所有源码,创建dist文件夹存放处理过后的文件,在各目录下创建gulpfile.js文件</p><p>在gulpfile.js中创建gulp任务,找到需要处理的文件经过.pipe处理输出到dist文件夹中,gulp任务创建完成后，下载</p><p>gulp-cli 命令行工具    在命令行中使用gulp命令来执行gulp任务 gulp 任务名即可</p><pre class=" language-js"><code class="language-js"><span class="token keyword">const</span> gulp <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'gulp'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//创建gulp任务gulp.task</span><span class="token comment" spellcheck="true">//第一个参数任务名,第二个参数任务的回调函数</span>gulp<span class="token punctuation">.</span><span class="token function">task</span><span class="token punctuation">(</span><span class="token string">'fisrt'</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'我的第一个gulp任务'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//gulp.src()获取处理的文件</span>    gulp<span class="token punctuation">.</span><span class="token function">src</span><span class="token punctuation">(</span><span class="token string">'./src/css/base.css'</span><span class="token punctuation">)</span>    <span class="token comment" spellcheck="true">//必须经过.pipe处理才能输出</span>        <span class="token punctuation">.</span><span class="token function">pipe</span><span class="token punctuation">(</span>gulp<span class="token punctuation">.</span><span class="token function">dest</span><span class="token punctuation">(</span><span class="token string">'dist/css'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">)</span></code></pre><p>gulp的插件:</p><ol><li>gulp-htmlmin:html代码压缩 安装 npm install   gulp-htmlmin</li><li>gulp-file-include:html公共模块提取 npm install gulp-file-include </li><li>gulp-less:less语法转化 npm install gulp-less </li><li>gulp-csso:css压缩 npm install gulp-csso</li><li>gulp-babel:JavaScript语法转化 npm install –save-dev gulp-babel @babel/core @babel/preset-env</li><li>gulp-uglify:压缩混淆js代码 npm install –save-dev gulp-uglify</li><li>！！！！！！注意！Gulp 4最大的变化就是你不能像以前那样传递一个依赖任务列表 如果Gulp是4.0的版本需要手动指定版本号 比如 npm install <a href="mailto:gulp@3.9.1">gulp@3.9.1</a> -D</li></ol><p>gulp插件的使用</p><p>使用npm下载插件        require引用插件        调用插件</p><p>找里面api怎么使用</p><p>gulp主要是为了项目上线给整个项目做了一些处理</p><h3 id="package-json的作用"><a href="#package-json的作用" class="headerlink" title="package.json的作用"></a>package.json的作用</h3><p>npm init 自动创建此文件后面 -y 都是用默认值</p><p>记录了项目的一些信息</p><p>在传输项目的时候不需要那些已经下载好的第三方模块文件夹,只需要package.json文件即可,然后用户根据此文件的”dependencies”属性依赖包直接npm install可以自动去找这个属性，来下载项目需要的第三方模块</p><h5 id="项目依赖"><a href="#项目依赖" class="headerlink" title="项目依赖"></a>项目依赖</h5><p>在项目的开发阶段和线上运营阶段，都需要依赖的第三方包，称为项目依赖。</p><p>使用<code>npm install 包名</code>命令下载的文件会默认被添加到package.json文件的dependencies字段中。</p><h5 id="开发依赖"><a href="#开发依赖" class="headerlink" title="开发依赖"></a>开发依赖</h5><p>在项目的开发阶段需要依赖，线上运营阶段不需要依赖的第三方包，称为开发依赖。</p><p>使用<code>npm install 包名 --save-dev</code>命令将包添加到package.json文件的devDependencies字段中。</p><p>npm install –production只下载dependencies中的依赖,即发布到线上时的依赖</p><p>package-lock.json记录了模块与模块之间依赖关系</p><p>版本和下载地址,加快了下载速度锁定了包的版本</p><p>“scripts”属性里存了一些命令的简写，如果写项目时有些比较长的命令需要重复输入,可以存在这个属性中定义一个简写    在命令行行中运行时 npm run 简写命令</p><h3 id="模块的查找规则"><a href="#模块的查找规则" class="headerlink" title="模块的查找规则"></a>模块的查找规则</h3><p>第一种方式require(‘./find.js’)引入模块参数是一个完整的路径文件,这会直接去找这个文件find.js</p><p>第二方式如果路径文件没有加后缀名require(‘./find’)</p><ul><li><p>首先去找当前文件夹下的find.js文件，如果找不到就在当前目录寻找同名文件夹</p></li><li><p>如果找了同名文件夹，就执行同名文件夹下index.js文件</p></li><li><p>如果同名文件夹中没有index.js，就会进入到同名文件夹根目录下的package.json文件中寻找里面main属性</p></li><li><p>如果在同名文件夹中找到了main属性中的js文件就引用成功,没找到则会报错</p></li></ul><p>第三种方式如果直接写模块名require(’find‘)</p><ul><li>首先会把find当成系统模块,如果没有该系统模块</li><li>则会当成第三方模块,则去node_modules文件夹下找同名的js文件</li><li>如果在node_modules文件夹下没有找到同名js文件，则会去找同名的js文件夹里面的index.js文件</li><li>如果没有找到index.js文件，则会通过同名文件夹下package.json去找main属性中入口文件,如果找不到则会报错</li></ul><p><strong>综上所述package.json中的main属性是模块的主模块文件,及模块的入口文件，里面所有的模块都依赖于这个主模块文件</strong></p><h3 id="node第一天的总结"><a href="#node第一天的总结" class="headerlink" title="node第一天的总结"></a>node第一天的总结</h3><p>​    node中最主要就是模块化开发，因此想要使用模块相当于引用文件需要用require()引入模块，有node环境自带的系统模块还有各种第三方模块，当你想使用哪个模块时就去文档里面找这个模块的一些api，知道api的用法和里面的参数和返回值，通过提供的这些api方法来进行操作，另外就是第三方模块可以用安装node后自带的npm工具下载，下载命令行辅助工具时一般是全局安装，查第三方模块api的使用</p><p>​    package.json文件主要记录了项目的一些信息，包括项目的名字、描述、项目的主入口文件、依赖的模块、简易化命令、代码协议等等。这个文件一般在项目的根目录,当我们导入别人的项目到本地时，可以通过这个文件中的依赖模块信息在npm下载模块，也可以查看到别人项目的信息等</p>]]></content>
      
      
      <categories>
          
          <category> node.js </category>
          
      </categories>
      
      
        <tags>
            
            <tag> node.js </tag>
            
            <tag> npm </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
